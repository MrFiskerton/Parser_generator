@header {
package mygenerated.obfuscate;
import generator.Tree;
}

@members {

private static Map<String, String> identifierMap = new HashMap<String, String>();

static void write(String x) {System.out.print(x);}

static void debug(String x) {System.err.print(x);}

static String last_result = "";

static String generateIdentifier() {
    StringBuilder result = new StringBuilder();
    Random r = new Random();

    final String alphabet = "OI10";

    if (!last_result.isEmpty()) {
        if (last_result.contains("0")) {
            last_result = last_result.replace('0', 'O');
            return last_result;
        } else if (last_result.contains("1")) {
            last_result = last_result.replace('1', 'I');
            return last_result;
        }
        last_result = "";
    }

    int min_length = 5;
    result.append(alphabet.charAt(r.nextInt(alphabet.length() - 2)));
    for (int i = 1; i < r.nextInt(13) + min_length; i++) {
        result.append(alphabet.charAt(r.nextInt(alphabet.length())));
    }
    last_result = result.toString();

    return last_result;
}

static void declareIdentifier(String identifier) {
    String new_identifier;

    //    debug("Declare:" + identifier + "\n");
    //    identifierMap.put(identifier, identifier + "NEW");
    //    return;

    do {
        new_identifier = generateIdentifier();
        //debug(new_identifier);
    } while (identifierMap.containsValue(new_identifier));
    identifierMap.put(identifier, new_identifier);
}


static String obfuscate(String identifier) {
    if(!identifierMap.containsKey(identifier)) {
        declareIdentifier(identifier);
    }
    //debug("identifierMap.get:" + identifierMap.get(identifier) + "\n");
    return identifierMap.get(identifier);
}

static void tabs(int amount) {for(int i=0; i<amount; i++) System.out.print(' ');}

}

start
    :   includes main EOF;

includes
    :   include includes
    |
    ;

include [IDENT i]
    :   INCLUDE LS i GR {write("#include <" + $i.text + ">\n");}
    |   INCLUDE LS i DOTH GR {write("#include <" + $i.text + ".h>\n");}
    ;

main
    :   INT MAIN LPAREN tmprparenprintmain tmplfparenprint items LRFPAREN {write(" ");};

tmprparenprintmain: RPAREN {write("\nint main () ");};
tmplfparenprint: LFPAREN {write("{\n");};

conditionStatement
    :   IF  tmplparenprintif expression tmprparenprinttabs compoundStatement tmpelseprinttabelse compoundStatement ;

tmplparenprintif: LPAREN {write("if (");};
tmprparenprinttabs: RPAREN {write(")\n");};
tmpelseprinttabelse: ELSE {write("\n");write("else\n");};

forStatement
    :  tmpforprintfor type simple_declaration tmpsemiprintsemi expression tmpsemiprintsemi expression tmprparenprinttabs forBody
    ;

tmpforprintfor: FOR LPAREN {write("for (");};
tmpsemiprintsemi: SEMI {write(";");};

forBody
    : '{'{write("{\n");} items[amount + 4]? '}'{write("}");}
    ;

expressionStatement[int amount]
    :   expression? ';'{write(";");}
    ;

compoundStatement[int amount]
    :   '{'{write("{\n");} items[amount + 4]? '}'{write("}");}
    ;

items
    :   tmpitemprint
    |   tmpitemprint items
    ;

tmpitemprint: item {write("\n");};

item
    :   declaration
    |   statement[amount]
    ;

declaration
    :   type multi_declaration';'{write(";");}
    ;

multi_declaration
    : simple_declaration (','{write(",");} multi_declaration)?
    ;

simple_declaration
    :   i=IDENT{declareIdentifier($i.text); write(" " + obfuscate($i.text)); } ('='{write(" = ");} assignExpression)?
    ;

statement[int amount]
    :   compoundStatement[amount]
    |   expressionStatement[amount]
    |   conditionStatement[amount]
    |   forStatement[amount]
    ;

expression
    :   assignExpression
    ;

assignOperator
    :   '='{write(" = ");}
    |   '*='{write(" *= ");}
    |   '/='{write(" /= ");}
    ;

assignExpression
    :   orCondition
    |   unary assignOperator assignExpression;

orCondition
    :   andCondition
    |   orCondition '||'{write(" || ");} andCondition
    ;

andCondition
    :   eqCondition
    |   andCondition '&&'{write(" && ");} eqCondition
    ;

eqCondition
    :   relCondition
    |   eqCondition '=='{write(" == ");} relCondition
    |   eqCondition '!='{write(" != ");} relCondition
    ;

relCondition
    :   additive
    |   relCondition '<'{write(" < ");} additive
    |   relCondition '>'{write(" > ");} additive
    ;

additive
    :   multiple
    |   additive '+'{write(" + ");} multiple
    |   additive '-'{write(" - ");} multiple;

multiple
    :   unary
    |   multiple '*'{write(" * ");} unary
    |   multiple '/'{write(" / ");} unary;

unary
    :   primary;

primary
    :   i=IDENT {write(obfuscate($i.text));}
    |   constant
    |   '('{write("(");} expression ')'{write(")");}
    ;

type
    :   'void' {write("void");}
    |   'char' {write("char");}
    |   'short' {write("short");}
    |   'int' {write("int");}
    |   'float' {write("float");}
    |   'double'{write("double");}
    ;

constant
    :   i=NUMBER {write($i.text);}
    |   i=NUMBER {write($i.text);} '.'{write(".");} i=NUMBER {write($i.text);}
    ;

INCLUDE: '#include';
DOTH: '.h';
LS: '<';
GR: '>';
LPAREN  : '(';
RPAREN  : ')';
LFPAREN: '{';
RFPAREN: '}';
DOT     : '.';
SEMI    : ';';
COMMA   : ',';

IF: 'if';
ELSE: 'else';
FOR: 'for';


VOID: 'void';
CHAR: 'char';
SHORT: 'short';
INT:   'int';
FLOAT: 'float';
DOUBLE: 'double';
MAIN: 'main';

IDENT:   [a-zA-Z_] ( [a-zA-Z_] | [0-9] )*;
NUMBER:   [1-9][0-9]*;

